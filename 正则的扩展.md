## 引子
> 这一章本应该是 *ES6 正则的扩展*，但是由于自己知识储备量太浅——正则的东西基本忘干净了。基本遇到什么东西对于我来又熟悉又陌生，不如从来不会。

### 基本语法
```
    // 字面量法
 /pattern/flags
 // 构造函数
 new RegExp(pattern,flags)
 // 工厂符号
 RegExp(pattern,flags)
```
###### 参数
* ***pattern***   
     正则表达式的文本
* ***flags***   
 如果指定，标志可以具备以下值的任意组合：  
    * **g**   
    全局匹配;找到所有匹配，而不是在第一个匹配后停止
    * **i**   
    忽略大小写
    * **m**   
    多行; 将开始和结束字符（^和$）视为在多行上工作（例如，分别匹配每一行的开始和结束（由 \n 或 \r 分割），而不只是只匹配整个输入字符串的最开始和最末尾处。
    * **u**   
    Unicode; 将模式视为Unicode序列点的序列
    * **y**   
    粘性匹配; 仅匹配目标字符串中此正则表达式的lastIndex属性指示的索引(并且不尝试从任何后续的索引匹配)。
### 正则表达式中特殊字符的含义  

#### 字符类别
* **.**  (点号，小数点) 匹配任意单个字符，但是行结束符除外：\n \r 。在字符集中，点( . )失去其特殊含义，并匹配一个字面点( . )。
* **\d**  匹配任意阿拉伯数字。等价于[0-9]。
* **\D**  匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。
* **\w**  	
匹配任意来自基本拉丁字母表中的字母数字字符，还包括下划线。等价于 [A-Za-z0-9_]。
* **\W**  匹配任意不是基本拉丁字母表中单词（字母数字下划线）字符的字符。等价于 [^A-Za-z0-9_]。
* **\s**  匹配一个空白符，包括空格、制表符、换页符、换行符和其他 Unicode 空格。
* **\S**  匹配一个非空白符。
* **\s**  匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。
* **\s**  匹配任意一个不是阿拉伯数字的字符。等价于[^0-9]。
#### 字符集合
* **[xyz]**  个字符集合，也叫字符组。匹配集合中的任意一个字符。你可以使用连字符'-'指定一个范围。
* **[^xyz]**  一个反义或补充字符集，也叫反义字符组。也就是说，它匹配任意不在括号内的字符。你也可以通过使用连字符 '-' 指定一个范围内的字符。
### 边界
* **^**  匹配输入开始。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符后的开始处。
* **$**  匹配输入结尾。如果多行（multiline）标志被设为 true，该字符也会匹配一个断行（line break）符的前的结尾处。
* **\b**  匹配一个零宽单词边界（zero-width word boundary），如一个字母与一个空格之间。 
* **\B** 匹配一个零宽非单词边界（zero-width non-word boundary），如两个字母之间或两个空格之间。
#### 分组和反向引用
* **(x)**  匹配 x 并且捕获匹配项。 这被称为捕获括号（capturing parentheses）。
* **\n**  n 是一个正整数。一个反向引用（back reference），指向正则表达式中第 n 个括号（从左开始数）中匹配的子字符串。

###### // 有必要写点注释。
> 简单的来说，圆括号就是用来分组的，括在一对括号里就是一个分组。用在什么地方？拿重复字母来说 */a{2}/*,重复字符“a”2次，重复一个一个字符串"abc"，这时候就得用到括号。 

> 括号的第一个作用就是将括起来的分组看成一个整体，作用就像上述栗子 */(abc){5}/*。

> 分组匹配到的内容也就是这个分组 捕获 到的内容， 从左往右，以左括号为标志，每个分组会自动拥有一个从1开始的编号 ，编号0的分组对应整个正则表达式， **JS不支持捕获组显示命名 **。

> 括号的第二个作用，分组捕获到的内容，可以在之后通过 \分组编号 的形式进行反向引用。比如 (ab|cd)123\1 可以匹配“ab123ab”或者“cd123cd”，但是不能匹配“ab123cd”或“cd123ab”，这里有一对括号，也是第一对括号，所以编号为捕获组1，然后在正则中通过 \1 去引用了捕获组1的捕获的内容，这叫 **反向引用** 。

> 括号的第三个作用，改变优先级，比如 abc|de 和 (abc|d)e 表达的完全不是一个意思。

#### 数量词
* **x***  匹配前面的模式 x 0 或多次。
* **x+**  匹配前面的模式 x 1 或多次。等价于 {1,}。
* ** x*? x+? **  像上面的 * 和 + 一样匹配前面的模式 x，然而匹配是最小可能匹配。
* **x?*** 如果在数量词 *、+、? 或 {}, 任意一个后面紧跟该符号（?），会使数量词变为非贪婪（ non-greedy） ，即匹配次数最小化。反之，默认情况下，是贪婪的（greedy），即匹配次数最大化。
* **x(?=y)***  只有当 x 后面紧跟着 y 时，才匹配 x。
* **x|y***  匹配 x 或 y
* **x{n}***  n 是一个正整数。前面的模式 x 连续出现 n 次时匹配。
* **x{n,}***  n 是一个正整数。前面的模式 x 连续出现至少 n 次时匹配。
* **x{n,m}***  n 和 m 为正整数。前面的模式 x 连续出现至少 n 次，至多 m 次时匹配。

###### // 又到了有必要写点注释的时候了。
> 像上述量词中，*x**、*x?*、*x+*、*x{n}*这些字符又叫限定符。在限定附中，除了 *x{n}* 确切表示重复几次，其余的都是一个有下限的范围。

> 这就引出了贪婪和非贪婪的定义。

> 在默认的模式（贪婪）下，会尽可能多的匹配内容。比如用 ab* 去匹配字符串“abbb”，结果是“abbb”。

> 而通过在限定符后面加问号 ? 可以进行非贪婪匹配，会尽可能少地匹配。用 ab*? 去匹配“abbb”，结果会是“a”。

> 不带问号的限定符也称匹配优先量词，带问号的限定符也称忽略匹配优先量词。

### 方法(ES5)
#### 用来匹配提取的方法——exec()

```
var matches=pattern.exec(str);

var s = 'aaa_aa_a';
var r1 = /a+/g
r1.exec(s);
// ["aaa"]
r1.exec(s);
// ["aa"]
r1.exec(s);
// ["a"]
r1.exec(s);
// null
```

如果匹配成功，*exec()*  方法返回一个数组，并更新正则表达式对象的属性。返回的数组将完全匹配成功的文本作为第一项，将正则括号里匹配成功的作为数组填充到后面。

如果匹配失败，*exec()* 方法返回 *null*。

##### 要注意的是:
> * *exec()* 永远只返回一个匹配项（指匹配整个正则的）
> * 如果设置了 g 修饰符，每次调用 *exec()* 会在字符串中继续查找新匹配项，不设置 g 修饰符，对一个字符串每次调用 *exec()* 永远只返回第一个匹配项。所以如果要匹配一个字符串中的所有需要匹配的地方，那么可以设置 g 修饰符，然后通过循环不断调用 *exec()* 方法。


#### 用来测试匹配成功与否的方法——test()
```
var result=pattern.test(str);
```

如果正则表达式与指定的字符串匹配 ，返回true；否则false。

> 当你想要知道一个模式是否存在于一个字符串中时，就可以使用 test()（类似于 String.prototype.search() 方法），差别在于test返回一个布尔值，而 search 返回索引（如果找到）或者-1（如果没找到）；

####  RegExp构造函数属性
* RegExp.input 或 RegExp["$_"] ：最近一次要匹配的字符串  
    ```
    var re = /hi/g;
    re.test('hi there!');
    RegExp.input;         // "hi there!"
    re.test('foo');       // 新测试，不匹配
    RegExp.$_;            // "hi there!"
    re.test('hi world!'); // 新测试，匹配
    RegExp.$_;            // "hi world!"
    ```
* RegExp.lastMatch 或 RegExp["$&"] ：最近一次匹配项  
    ```
    var re = /hi/g;
    re.test('hi there!');
    // lastMatch 属性的值是只读的，并且会在匹配成功时修改。
    RegExp.lastMatch; // "hi"
    RegExp['$&'];     // "hi"
    ```
    这个属性就不能使用属性访问器(RegExp.$&)来使用简写的别名，因为解析器在这里会将 "&" 看做表达式，并抛出 SyntaxError 。
* RegExp.lastParen 或 RegExp["$+"] ：最近一次匹配的捕获组
* RegExp.leftContext 或 RegExp["$`"] ：input字符串中lastMatch之前的文本
* RegExp.rightContext 或 RegExp["$'"] ：input字符串中lastMatch之后的文本
* RegExp["$n"] ：表示第n个捕获组的内容，n取1-9

---

## ES6 正则的扩展

> 咳咳，进入正题了。

### RegExp 构造函数
在ES5 中，RegExp 构造函数只能接受字符串作为参数。
```
    var regexp = new RegExp('abc','i');
    //等价于
    var regexp = /abc/i;
```
ES6 允许RegExp构造函数接受正则表达式作为参数，这时会返回一个原有正则表达式的拷贝。
> 如果使用RegExp 构造函数的第二个参数指定修饰符，则返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。

### 字符串的正则方法
字符串对象共有4个方法使用正则表达式：match()、replace()、search()和splice()。

ES6 将这4个方法在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法都定义在RegExp对象上。
* ***String.prototype.match()*** 调用 ***regexp[Symbol.match](str)***
* ***String.prototype.replace()*** 调用 ***regexp[Symbol.replace](str)*** 
* ***String.prototype.search()*** 调用 ***regexp[Symbol.search](str)***
* ***String.prototype.和splice()*** 调用 ***regexp[Symbol.splice](str)***


### y修饰符
ES6还为正则表达式添加了 *y* 修饰符，叫做“粘连”（sticky）修饰符。

 *y* 修饰符的作用与 *g* 修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于， *g* 修饰符只要剩余位置中存在匹配就可，而 *y* 修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。
 ```
 var s = 'aaa_aa_a';
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // ["aaa"]
r2.exec(s) // ["aaa"]

r1.exec(s) // ["aa"]
r2.exec(s) // null
 ```
 上面代码有两个正则表达式，一个使用g修饰符，另一个使用 *y* 修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是* _aa_a *。由于 *g* 修饰没有位置要求，所以第二次执行会返回结果，而 *y* 修饰符要求匹配必须从头部开始，所以返回null。
```
const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, '3 + 4')
// [ '3', '+', '4' ]
tokenize(TOKEN_G, '3 + 4')
// [ '3', '+', '4' ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
```
上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。
```
tokenize(TOKEN_Y, '3x + 4')
// [ '3' ]
tokenize(TOKEN_G, '3x + 4')
// [ '3', '+', '4' ]
```
上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。

### sticky属性
与y修饰符相匹配，ES6的正则对象多了sticky属性，表示是否设置了y修饰符。
```
var r = /hello\d/y;
r.sticky // true
```
### flags属性

ES6为正则表达式新增了flags属性，会返回正则表达式的修饰符。
```
// ES5的source属性
// 返回正则表达式的正文
/abc/ig.source
// "abc"

// ES6的flags属性
// 返回正则表达式的修饰符
/abc/ig.flags
// 'gi'
```

### RegExp.escape()
字符串必须转义，才能作为正则模式。
```
RegExp.escape('The Quick Brown Fox');
// "The Quick Brown Fox"

RegExp.escape('Buy it. use it. break it. fix it.');
// "Buy it\. use it\. break it\. fix it\."

RegExp.escape('(*.*)');
// "\(\*\.\*\)"
```
字符串转义以后，可以使用RegExp构造函数生成正则模式。字符串转义以后，可以使用RegExp构造函数生成正则模式。

## 应用正则的实践思路

应用正则，一般是要先想到正则（废话），只要看到和“找”相关的需求并且这个源是可以被字符串化的，就可以想到用正则试试。

一般在应用正则有两类情况，一是验证类问题，另一类是搜索、提取、替换类问题。验证，最常见的如表单验证；搜索，以某些设定的命令加关键词去搜索；提取，从某段文字中提取什么，或者从某个JSON对象中提取什么（因为JSON对象可以字符串化啊）；替换，模板引擎中用到。

1. 验证类问题
验证类问题是我们最常遇到的，这个时候其实源字符串长什么样我们是不知道，鬼知道萌萌哒的用户会做出什么邪恶的事情来，推荐的方式是这样的:
    1. 首先用白话描述清楚你要怎样的字符串，描述好了之后，就开脑洞地想用户可能输入什么奇怪的东西，就是自己举例，拿一张纸可举一大堆的，有接受的和不接受的（这个是你知道的），这个过程中可能你会去修改之前的描述；
    1. 把你的描述拆解开来，翻译成正则表达式；
    3. 测试你的正则表达式对你之前举的例子的判断是不是和你预期一致，这里就推荐用在线的JS正则测试去做，不要自己去一遍遍写了。
2. 搜索、提取、替换类问题
这类问题，一般我们是知道源文本的格式或者大致内容的，所以在解决这类问题时一般已经会有一些测试的源数据，我们要从这些源数据中提取出什么、或者替换什么。
    1. 找到这些手上的源数据中你需要的部分；
    2. 观察这些部分的特征，这些部分本身的特征以及这些部分周围的特征，比如这部分前一个符号一定是一个逗号，后一个符号一定是一个冒号，总之就是找规律；
    3. 考察你找的特征，首先能不能确切地标识出你要的部分，不会少也不会多，然后考虑下以后的源数据也是如此么，以后会不会这些特征就没有了；
    4. 组织你对要找的这部分的描述，描述清楚经过你考察的特征；
    5. 翻译成正则表达式；
    6. 测试。    
#### 参考：
* ES6 入门标准（第二版）
* [JS正则表达式一条龙讲解……](https://segmentfault.com/a/1190000008088937)
*  JavaScript 高级程序设计
*  [MDN RegExp](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/RegExp)


---
> 究其根源正则还是用的少，可以说是根本没用过。需要用到正则的时候思路根本不会像其靠拢，*"应用正则，一般是要先想到正则"*。
最近写后台写功能，处理数据才渐渐想起了正则，应用的也是比较简单的。总的来说，时长总结看看还是有帮助的。  
> 最近两章字符串、正则都有写到对unicode的拓展的内容，我在这也没有写上，逃避了这一块，因为我还真是不太懂，只能等条件成熟再来补上。
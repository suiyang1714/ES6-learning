### 数组的解构
---
#### 基本用法
*ES6* 允许按照一定的模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（*Destructuring*）。
以前的变量赋值都是，只能直接指定值
```
    
    var a = 1;
    var b = 2;
    var c = 3;
    
    //es6允许这样写
    
    var [a,b,c] = [1,2,3];
    
```
本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。
```
    let [a,[b,c]] = [1,[2,3]];
    a //1
    b //2
    c //3
    
    let [ , ,y] = [1,2,3]
    y //3
    
    let [a,,c] = [1,2,3]
    
    a //1
    c //3
    
    let [head, ...tail] = [1,2,3,4];
    head //1
    tail //[2,3,4]
    
    let [a,b, ...c] = [1]
    a //1
    b // undefined
    c // []
    
```
如过解构不成功，变量的值就等于*undefined*。
还有种情况是不完全解构，即等号左边的模式只匹配
等号右边数组的一部分。这样依然属于解构成功。

如果等号的右边不是数组（或者严格地说，不是可遍历的结构），那么将会报错。
```
    //报错
    
    let [a] = 1;
    let [a] = false;
    let [a] = NaN;
    let [a] = undefined;
    let [a] = null;
    let [a] = {};
    
```

#### 默认值
结构赋值允许制定默认值。
该默认值生效的前提是，右侧对应的数组成员为*undefined*。

*ES6* 内使用严格相等运算符（===）判断一个位置是否有值，所以一个数组成员不严格等于*undefined*，默认值是不会生效的。

如果默认值是一个表达式，那么这个表达式是惰性求值，即只有在用到的时候才会求值

默认值还可以引用结构赋值的其他变量，但该变量必须已经声明。
```
    var [a = 1] = [undefined];
    a //1
    
    var [a = 2] = [null];
    a //null
    
    function f(){
        console.log('aaa')
    };
    var [a = f()] = [1];
    
    // 等价于
    
    let a;
    if([1][0] === undefined){
        x = f();
    }
    else {
        x = [1][0]
    }
    
    let [x=1,y=1] = [];  //x=1,y=1
    let [x=1,y=x] = [2]; //x=2,y=2
    let [x=y,y=1] = [];  //ReferenceError
```
### 对象结构

对象结构与数组的有一个重要的区别。数组的元素是按次序排列的，变量的取值由它的位置决定；对象的属性没有次序，变量必须与属性同名，才能取到值。

```
    var {a,b} = {a:'1',c:'2'}
    a //'1'
    b //undefined
    

```
变量名如果和属性名不一致，只能将变量名也作为左侧属性，对应右侧属性。也就是说，对象的结构赋值的内部机制，是先找到同名属性，然后赋值给对应的变量。真正被赋值的后者，而不是前者。
```
    var {a:aaa} = { a: "1",b: "2" };
    aaa //"1"
    
    let obj = { a: 1,b:2 };
    let { a: aaa,b: bbb } = obj
    aaa // 1
    bbb // 2
    
```

需要注意的是，结构赋值的变量都会被重新声明，如果使用*let* 或者*const*被先一步声明，解构的过程就会报错。


```
    var x;
    {x} = {x = 1}; //SyntaxError: syntax error
    // 报错的原因是JavaScript引擎会将{x}理解为一个代码块，从而发生语法错误，只有不将大括号写在行首才能解决。
    ({x} = { x = 1 });
    
    
```
### 字符串解构赋值

当字符串进行解构的时候，此时字符串将被转换成一个类似数组的数组的对象。

```
    const [a,b,c,d,e] = 'hello';
    a //'h'
    b //'e'
    c //'l'
    d //'l'
    e //'o'
    
    let {length: len} = 'length';
    len //5
```
类似数组的对象都有*length* 属性，因此还可以对这个属性结构赋值。

### 数值和布尔值的结构赋值

```
let {toString:s}=123;
console.log(s===Number.prototye.toString)//true
console.log(s);//function toString()

let {a:s}=123;
console.log(s);//undefined
```
> 阮老师给出的解释是：解构赋值时，如果等号右边是数值或者布尔值，那么会先转为对象，上面的代码中,数值的包装对象有toString方法，所以变量s可以取到。

通俗点解释就是：等号右侧如果是数值或者布尔值，那么优先转成对象，然后会遍历对象中所有方法，如果找到对应的方法，则结构成功，否则失败。这也是属于 *不完全解构* 。
上述栗子也是相当于
*let {log,sin.cos} = Math*,由于Math对象拥有前面三个方法，所以解构成功。

像 *null* 、 *undefined* 都无法转成对象，对他们进行解构赋值都会报错。

### 函数参数的解构赋值

函数传参利用解构赋值，可以说是比较灵活的一种方法。可以选择数组形式也可以是对象形式。

```
    function move({x:0,y:0} = {}) {
        return [x,y]
    }
    
    mvoe({x:3,y:8}); // [3,8]  
    mvoe({x:3}); // [3,0]
    move({});  //[0,0]
    move(); //[0,0]
    
```

函数 *move* 的参数是一个对象，并对他进行解构。
上述代码对象指定了默认值，当函数可以传参数 *move({x:3,y:8})*,在函数 *function* 里表示：
> {x=0,y=0} = {x:3,y:8}

对象的解构赋值右边对象有值了，不再是空对象了，也就是说对象里面不再是 *undefined* 了，那么解构赋值中就不能使用默认值了*x=0,y=0*，所以赋值的结果是*x=3,y=8*.

中等号右边的空对象为参数赋值的默认值，也就是说{}是move函数参数的默认值，如果 *move函数* 不传参，那么对象解构的时候是按照 *{x=0,y=0}={}* 来解构的。如果函数传参 *obj* ，则按照 *{x=0,y=0}=obj* 来解构。

再一种就是需要解构的对象没有默认值

```
    function move({x,y} = {x:0,y:0}) {
        return [x,y]
    }
    
    mvoe({x:3,y:8}); // [3,8]  
    mvoe({x:3}); // [3,undefined]
    move({});  //[undefined,undefined]
    move(); //[0,0]
    
```

通过结果可以看出，采用 *{x=0,y=0} =  {}* 的形式，无论怎么传参，都能保证 *x，y* 的默认值是0，但是采用 *{x,y} = {x:0,y:0}* 的形式，如果传入的参数值不是 *undefined* ，那么将不能有效保证函数参数默认值是0

### 圆括号问题

前面遇到了使用圆括号的地方，这里再拿过来用一下
```
    var x;
    {x} = {x = 1}; //SyntaxError: syntax error
    
    ({x} = { x = 1 });
    
    
```
前面也解释了原因：JavaScript引擎会将{x}理解为一个代码块，从而发生语法错误，只有将大括号写在行首才能解决。
那么也引出一个问题，什么时候用圆括号，什么时候不用圆括号？
因为ES6中也是明确规定，只要有可能导致解构歧义，就不得使用圆括号。

#### 不能使用圆括号的情况
* 变量声明语句中，模式不能带有圆括号。
     ```
     //全部报错
     var [(a)] = [1];
     var {x:(c)} = {};
     var {o:({p:p})} = {o:{p:2}}
     ```
     
*  函数参数中，模式不能带有圆括号。简单的说函数参数也属于声明变量，因此不能带有圆括号。
*  不能将整个模式或嵌套模式中的一层放在圆括号中


#### 可以使用圆括号的情况
赋值语句的非模式部分可以使用圆括号。
 ```
    [(a)] = [1];
    ({x:(c)} = {});
    [(a.b)] = [3];
    
```

### 用途
光从开始看到的时候，每看到一种变量的解构赋值的时候，还在想什么地方能用到。
#### 交换变量的值
```
[a,b] = [b,a]
```

#### 从函数中返回多个值
函数只能返回返回一个值，如果要返回多个值，只能将其放在数组活对象中返回，在解构赋值中，取这些值就简单很多
```
    // 返回一个数组
    
    function example(){
        return [1,2,3]
    }
    var [a,b,c] = example()
    a //1
    b //2
    c //3
    
    // 返回一个对象
    function example(){
        return {
            a:1,
            b:2
        }
    }
    var {a,b} = example()
    a //1
    b //2
```

#### 函数参数指定默认值
当传入参数为空的时候，不会报错，或者需要判断

#### 输入模块的指定方法

加载模块时，往往需要指定输入那些方法。解构赋值使得输入语句非常清晰

```
    const { SourceMapConsumer,Map  } = require(sorce-map)
```


